import{_ as i,c as s,o as e,a3 as l}from"./chunks/framework.BYhES31N.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"base/linux/cpu-land/cpu-land-03.md","filePath":"base/linux/cpu-land/cpu-land-03.md","lastUpdated":1716462420000}'),a={name:"base/linux/cpu-land/cpu-land-03.md"},n=l('<h3 id="第三章-运行程序" tabindex="-1">第三章：运行程序 <a class="header-anchor" href="#第三章-运行程序" aria-label="Permalink to &quot;第三章：运行程序&quot;">​</a></h3><blockquote><p>这篇文章是关于如何在Linux操作系统上执行程序的详细解析。</p></blockquote><p><strong>1. 背景知识：</strong></p><ul><li>文章首先回顾了CPU执行机器码、基于环的安全模型以及系统调用（syscalls）的基础知识。</li></ul><p><strong>2. Linux内核与x86-64架构：</strong></p><ul><li>专注于Linux操作系统在x86-64架构上的程序加载和运行机制。</li><li>Linux是开源的，易于通过阅读源代码进行研究。</li><li>x86-64架构是现代桌面计算机常用的架构，也是许多代码的目标架构。</li></ul><p><strong>3. exec系统调用（Syscalls）：</strong></p><ul><li><code>execve</code>是用于加载程序并替换当前进程的系统调用。</li><li>其他如<code>execlp</code>、<code>execvpe</code>等系统调用都是建立在<code>execve</code>之上的。</li></ul><p><strong>4. execve的工作原理：</strong></p><ul><li><code>execve</code>调用签名：<div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">filename</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> envp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li><code>filename</code>参数指定要运行的程序路径。</li><li><code>argv</code>是程序参数的空终止列表。</li><li><code>envp</code>包含环境变量的空终止列表。</li></ul><p><strong>5. execve的内部实现：</strong></p><ul><li><code>SYSCALL_DEFINE3</code>宏定义了一个三参数系统调用的代码。</li><li><code>getname()</code>函数用于将用户空间的字符串复制到内核空间。</li></ul><p><strong>6. linux_binprm结构体：</strong></p><ul><li>用于准备新程序的虚拟内存管理。</li><li>存储<code>argc</code>、<code>envc</code>、<code>filename</code>、<code>interp</code>和缓冲区<code>buf</code>。</li></ul><p><strong>7. Binfmt处理程序：</strong></p><ul><li>内核通过迭代一系列binfmt（二进制格式）处理程序来确定程序的格式。</li><li>每个处理程序都有一个<code>load_binary()</code>函数，用于检查程序格式并准备执行。</li></ul><p><strong>8. 脚本格式处理：</strong></p><ul><li>脚本的shebang（#!）行是由内核处理的，而不是由shell处理。</li><li>如果文件以shebang开头，binfmt处理程序将读取解释器路径和参数。</li></ul><p><strong>9. 脚本参数修改：</strong></p><ul><li><code>binfmt_script</code>假定<code>argv[0]</code>是程序名称，并会修改<code>argv</code>，添加解释器路径和参数。</li></ul><p><strong>10. binfmt_misc：</strong></p><ul><li>允许通过用户空间配置添加有限格式的处理程序。</li><li>通过挂载特殊文件系统<code>/proc/sys/fs/binfmt_misc/</code>来配置。</li></ul><p><strong>11. exec系统调用的结果：</strong></p><ul><li>如果找到可执行的二进制格式，内核将运行该代码，替换旧代码。</li><li>如果没有找到合适的格式处理程序，将返回错误码。</li></ul><p><strong>12. 没有shebang的脚本：</strong></p><ul><li>如果exec调用失败，大多数shell会将文件作为shell脚本重新尝试执行。</li></ul><p><strong>13. POSIX标准：</strong></p><ul><li>如果exec调用因<code>ENOEXEC</code>错误失败，shell将执行一个命令，相当于调用shell并传递命令名称作为第一个参数。</li></ul><p>文章通过深入探讨Linux内核的源代码，详细解释了如何在Linux上加载和执行程序，包括<code>execve</code>系统调用的内部工作机制以及如何处理脚本和二进制格式。这些信息对于理解操作系统的工作原理非常有用。</p>',29),t=[n];function o(c,p,d,r,h,k){return e(),s("div",null,t)}const _=i(a,[["render",o]]);export{u as __pageData,_ as default};
