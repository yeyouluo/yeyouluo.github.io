import{_ as o,c as l,o as i,a3 as e}from"./chunks/framework.BYhES31N.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"base/linux/cpu-land/cpu-land-06.md","filePath":"base/linux/cpu-land/cpu-land-06.md","lastUpdated":1716462420000}'),t={name:"base/linux/cpu-land/cpu-land-06.md"},n=e('<h3 id="第六章-谈谈分叉和写时复制-cow" tabindex="-1">第六章：谈谈分叉和写时复制（COW） <a class="header-anchor" href="#第六章-谈谈分叉和写时复制-cow" aria-label="Permalink to &quot;第六章：谈谈分叉和写时复制（COW）&quot;">​</a></h3><blockquote><p>这篇文章详细探讨了Unix系统中的进程创建和管理，特别是<code>fork</code>系统调用和写时复制（Copy On Write, COW）机制。</p></blockquote><p><strong>1. 进程的起源：</strong></p><ul><li>所有计算机上的进程都是由一个父程序通过<code>fork-exec</code>模式创建的，除了init进程。</li></ul><p><strong>2. <code>fork</code>系统调用：</strong></p><ul><li><code>fork</code>是创建新进程的基础系统调用，它克隆当前进程及其内存，并允许两个进程继续正常运行。</li><li>新创建的进程称为“子进程”，调用<code>fork</code>的进程称为“父进程”。</li><li><code>fork</code>在父进程中返回子进程的PID，在子进程中返回0。</li></ul><p><strong>3. <code>fork</code>的效率：</strong></p><ul><li><code>fork</code>通过复制旧进程的页表来创建新进程，而不是复制RAM，这使得<code>fork</code>操作非常高效。</li></ul><p><strong>4. 写时复制（COW）：</strong></p><ul><li>COW机制允许父进程和子进程在没有写入尝试时共享相同的物理内存地址。</li><li>当任一进程尝试写入内存时，会触发硬件中断，由内核处理，复制内存页，允许写入，并重新尝试写入操作。</li></ul><p><strong>5. init进程：</strong></p><ul><li>init进程是由内核直接设置的第一个用户空间程序，负责启动操作系统中的所有程序和服务。</li><li>在Unix-like系统中，杀死init进程（PID 1）将关闭操作系统环境。</li></ul><p><strong>6. 内核启动init进程：</strong></p><ul><li>计算机启动时，BIOS寻找启动引导程序，加载并执行它。</li><li>引导程序加载内核到RAM并执行。</li><li>内核运行初始化任务，包括设置中断处理程序、加载驱动程序、创建初始内存映射，然后启动init程序。</li></ul><p><strong>7. Linux中的初始化：</strong></p><ul><li>在Linux中，大部分内核初始化发生在<code>start_kernel</code>函数中。</li><li><code>rest_init</code>函数创建init进程的线程。</li></ul><p><strong>8. 程序的运行：</strong></p><ul><li>程序通过处理器执行内存中的指令序列来运行。</li><li>中断和系统调用允许程序间接访问系统资源。</li></ul><p><strong>9. 程序的启动：</strong></p><ul><li>内核启动后，init进程开始运行，使用<code>fork-exec</code>模式启动其他程序。</li><li><code>fork</code>创建新进程，<code>execve</code>替换当前进程为新程序。</li></ul><p><strong>10. ELF文件和内核：</strong></p><ul><li>新程序通常是ELF文件，内核解析ELF文件以确定如何加载程序以及在虚拟内存映射中放置代码和数据。</li></ul><p><strong>11. 程序执行的总结：</strong></p><ul><li>程序运行在用户模式下，通过系统调用间接访问I/O。</li><li>内核负责加载程序的虚拟内存映射，并设置CPU的指令指针到新程序的代码起始处。</li></ul><p>文章通过解释<code>fork</code>和COW机制，帮助读者理解Unix系统中程序是如何被创建和执行的。这些机制对于确保系统的稳定性和效率至关重要。</p>',25),c=[n];function r(d,s,a,p,u,_){return i(),l("div",null,c)}const k=o(t,[["render",r]]);export{f as __pageData,k as default};
