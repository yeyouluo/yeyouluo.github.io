<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yeyouluo.github.io</id>
    <title>Ye Youluo&apos;s Blog</title>
    <updated>2020-06-26T04:13:49.616Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yeyouluo.github.io"/>
    <link rel="self" href="https://yeyouluo.github.io/atom.xml"/>
    <subtitle>知识，本该纯粹真实。 不应为乱象而迷失，因避讳而藏掖。</subtitle>
    <logo>https://yeyouluo.github.io/images/avatar.png</logo>
    <icon>https://yeyouluo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Ye Youluo&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Java并发编程笔记[2]——并发理论基础（下）]]></title>
        <id>https://yeyouluo.github.io/post/java-bing-fa-bian-cheng-bi-ji-2-bing-fa-li-lun-ji-chu-xia/</id>
        <link href="https://yeyouluo.github.io/post/java-bing-fa-bian-cheng-bi-ji-2-bing-fa-li-lun-ji-chu-xia/">
        </link>
        <updated>2020-06-26T02:32:45.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="并发编程中的安全性-活跃性-性能">并发编程中的安全性、活跃性、性能</h2>
<blockquote>
<p>并发编程是一个复杂的技术领域，微观上涉及到原子性问题、可见性问题和有序性问题，宏观则表现为安全性、活跃性以及性能问题。</p>
</blockquote>
<p>并发编程中需要注意的问题主要有3个：安全性、活跃性、性能。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="并发编程中的安全性-活跃性-性能">并发编程中的安全性、活跃性、性能</h2>
<blockquote>
<p>并发编程是一个复杂的技术领域，微观上涉及到原子性问题、可见性问题和有序性问题，宏观则表现为安全性、活跃性以及性能问题。</p>
</blockquote>
<p>并发编程中需要注意的问题主要有3个：安全性、活跃性、性能。</p>
<!-- more -->
<h3 id="安全性问题">安全性问题</h3>
<p>什么是线程安全呢？其实本质上就是<strong>正确性</strong>，而正确性的含义就是<strong>程序按照我们期望的执行</strong>，不要让我们感到意外。我们已经见识过很多诡异的 Bug，都是出乎我们预料的，它们都没有按照我们期望的执行。<br>
如何才能写出线程安全的程序呢？之前的文章中已经介绍了并发 Bug 的三个主要源头：原子性问题、可见性问题和有序性问题。也就是说，<strong>理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题</strong>。<br>
是不是所有的代码都需要认真分析一遍是否存在这三个问题呢？当然不是，其实只有一种情况需要：<strong>存在共享数据并且该数据会发生变化</strong>，通俗地讲就是<strong>有多个线程会同时读写同一数据</strong>。那如果能够做到不共享数据或者数据状态不发生变化，不就能够保证线程的安全性了嘛。有不少技术方案都是基于这个理论的，例如线程本地存储（Thread Local Storage，TLS）、不变模式等等。<br>
当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug，对此还有一个专业的术语，叫做<strong>数据竞争</strong>（Data Race）。<br>
<strong>竞态条件</strong>（Race Condition），指的是<strong>程序的执行结果依赖线程执行的顺序</strong>。<br>
面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用<strong>互斥</strong>这个技术方案，而实现互斥的方案有很多，CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。从逻辑上来看，我们可以统一归为：<strong>锁</strong>。</p>
<h3 id="活跃性问题">活跃性问题</h3>
<p>所谓活跃性问题，指的是<strong>某个操作无法执行下去</strong>。我们常见的『<strong>死锁</strong>』就是一种典型的活跃性问题，当然除了死锁外，还有两种情况，分别是『<strong>活锁</strong>』和『<strong>饥饿</strong>』。</p>
<h4 id="活锁">活锁</h4>
<p><em>有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况</em>，这就是所谓的『<strong>活锁</strong>』。<br>
解决『活锁』的方案很简单，谦让时，尝试等待一个随机的时间就可以了。「等待一个随机时间」的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。</p>
<h4 id="饥饿">饥饿</h4>
<p>『饥饿』指的是<em>线程因无法访问所需资源而无法执行下去的情况</em>。“不患寡，而患不均”，如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。<br>
解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。<br>
那如何公平地分配资源呢？在并发编程里，主要是使用『<strong>公平锁</strong>』。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。</p>
<h3 id="性能问题">性能问题</h3>
<p>使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能。所以我们要尽量减少串行。<br>
使用锁的时候一定要关注对性能的影响。 那怎么才能避免锁带来的性能问题呢？这个问题很复杂，<strong>Java SDK 并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能</strong>。<br>
从方案层面，我们可以这样来解决这个问题。<br>
第一，既然使用锁会带来性能问题，那最好的方案自然就是使用<strong>无锁</strong>的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好……<br>
第二，<strong>减少锁持有的时间</strong>。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术（这个技术后面我们会详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。<br>
性能方面的度量指标有很多，有三个指标非常重要，就是：吞吐量、延迟和并发量。</p>
<ul>
<li>吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。</li>
<li>延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。</li>
<li>并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。</li>
</ul>
<h3 id="管程并发编程的万能钥匙">管程：并发编程的万能钥匙</h3>
<p>管程（Monitor）是一把解决并发编程的 万能钥匙。<br>
『<strong>管程</strong>』，指的是<strong>管理共享变量以及对共享变量的操作过程，让他们支持并发</strong>。翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。<br>
Java 内置的管程方案（synchronized）使用简单，synchronized 关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是仅支持一个条件变量；而 Java SDK 并发包实现的管程支持多个条件变量，不过并发包里的锁，需要开发人员自己进行加锁和解锁操作。<br>
并发编程里两大核心问题——互斥和同步，都可以由管程来帮你解决。学好管程，理论上所有的并发问题你都可以解决，并且很多并发工具类底层都是管程实现的，所以学好管程，就是相当于掌握了一把并发编程的万能钥匙。<br>
<img src="https://yeyouluo.github.io/post-images/1593140500490.png" alt="" loading="lazy"><br>
管程是一种概念，任何语言都可以通用。<br>
在java中，每个加锁的对象都绑定着一个管程（监视器）<br>
线程访问加锁对象，就是去拥有一个监视器的过程。如一个病人去门诊室看医生，医生是共享资源，门锁锁定医生，病人去看医生，就是访问医生这个共享资源，门诊室其实是监视器（管程）。<br>
所有线程访问共享资源，都需要先拥有监视器。就像所有病人看病都需要先拥有进入门诊室的资格。<br>
监视器至少有两个等待队列。一个是进入监视器的等待队列，一个是条件变量对应的等待队列。后者可以有多个。就像一个病人进入门诊室诊断后，需要去验血，那么它需要去抽血室排队等待。另外一个病人心脏不舒服，需要去拍胸片，去拍摄室等待。<br>
监视器要求的条件满足后，位于条件变量下等待的线程需要重新在门诊室门外排队，等待进入监视器。就像抽血的那位，抽完后，拿到了化验单，然后，重新回到门诊室等待，然后进入看病，然后退出，医生通知下一位进入。</p>
<p>总结起来就是，管程就是一个对象监视器。任何线程想要访问该资源，就要排队进入监控范围。进入之后，接受检查，不符合条件，则要继续等待，直到被通知，然后继续进入监视器。</p>
<h2 id="线程生命周期">线程生命周期</h2>
<h3 id="通用线程生命周期五态模型">通用线程生命周期——五态模型</h3>
<p><img src="https://yeyouluo.github.io/post-images/1593140878869.png" alt="" loading="lazy"><br>
这五种状态在不同编程语言里会有简化合并。例如，C 语言的 POSIX Threads 规范，就把初始状态和可运行状态合并了；Java 语言里则把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而 JVM 层面不关心这两个状态，因为 JVM 把线程调度交给操作系统处理了。<br>
除了简化合并，这五种状态也有可能被细化，比如，Java 语言里就细化了休眠状态（这个下面我们会详细讲解）。</p>
<h3 id="java线程生命周期">Java线程生命周期</h3>
<p>Java 语言中线程共有六种状态，分别是：</p>
<ul>
<li>NEW（初始化状态）</li>
<li>RUNNABLE（可运行 / 运行状态）</li>
<li>BLOCKED（阻塞状态）</li>
<li>WAITING（无时限等待）</li>
<li>TIMED_WAITING（有时限等待）</li>
<li>TERMINATED（终止状态）<br>
<img src="https://yeyouluo.github.io/post-images/1593140973934.png" alt="" loading="lazy"></li>
</ul>
<h4 id="状态转换">状态转换</h4>
<h5 id="runnable-blocked">RUNNABLE ==&gt; BLOCKED</h5>
<p>只有一种场景会触发这种转换，就是<strong>线程等待 synchronized 的隐式锁</strong>。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。而当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。</p>
<blockquote>
<p>线程调用阻塞式 API 时，是否会转换到 BLOCKED 状态呢？在操作系统层面，线程是会转换到休眠状态的，但是在 JVM 层面，Java 线程的状态不会发生变化，也就是说 Java 线程的状态会依然保持 RUNNABLE 状态。JVM 层面并不关心操作系统调度相关的状态，因为在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。而我们平时所谓的 Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态。</p>
</blockquote>
<h5 id="runnable-waiting">RUNNABLE ==&gt; WAITING</h5>
<p>有三种场景会触发这种转换。<br>
第一种场景，获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法。<br>
第二种场景，调用无参数的 Thread.join() 方法。<br>
第三种场景，调用 LockSupport.park() 方法。Java 并发包中的锁，都是基于 LockSupport实现的。调用 LockSupport.park() 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark(Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。</p>
<h5 id="runnable-timed_waiting">RUNNABLE ==&gt; TIMED_WAITING</h5>
<p>有五种场景会触发这种转换：</p>
<ol>
<li>调用带超时参数的 Thread.sleep(long millis) 方法；</li>
<li>获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法；</li>
<li>调用带超时参数的 Thread.join(long millis) 方法；</li>
<li>调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法；</li>
<li>调用带超时参数的 LockSupport.parkUntil(long deadline) 方法。</li>
</ol>
<p>这里你会发现 TIMED_WAITING 和 WAITING 状态的区别，仅仅是触发条件多了超时参数。</p>
<h5 id="new-runnable">NEW ==&gt; RUNNABLE</h5>
<p>从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 start() 方法就可以了。</p>
<h5 id="runnable-terminated">RUNNABLE ==&gt; TERMINATED</h5>
<ul>
<li>线程执行完 run() 方法后，会自动转换到 TERMINATED 状态。</li>
<li>如果执行 run() 方法的时候异常抛出，也会导致线程终止。</li>
<li>强制中断 run() 方法的执行：①stop() 方法（@Deprecated），② interrupt() 方法。</li>
</ul>
<blockquote>
<p>stop() 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 ReentrantLock 锁，被 stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有 suspend() 和 resume() 方法，这两个方法同样也都不建议使用了。</p>
</blockquote>
<h4 id="理解java线程生命周期的意义">理解Java线程生命周期的意义</h4>
<p>Java 线程的各种状态以及生命周期对于诊断多线程 Bug 非常有帮助，多线程程序很难调试，出了 Bug 基本上都是靠日志，靠线程 dump 来跟踪问题，分析线程 dump 的一个基本功就是分析线程状态，大部分的死锁、饥饿、活锁问题都需要跟踪分析线程的状态。同时，本文介绍的线程生命周期具备很强的通用性，对于学习其他语言的多线程编程也有很大的帮助。<br>
可以通过 jstack 命令或者Java VisualVM这个可视化工具将 JVM 所有的线程栈信息导出来，完整的线程栈信息不仅包括线程的当前状态、调用栈，还包括了锁的信息。导出线程栈，分析线程状态是诊断并发问题的一个重要工具。</p>
<h2 id="创建多少线程合适">创建多少线程合适</h2>
<p>所谓提升性能，从度量的角度，主要是<strong>降低延迟，提高吞吐量</strong>（延迟是时间维度，吞吐量是空间维度）。这也是我们使用多线程的主要目的。<br>
在并发编程领域，提升性能本质上就是<strong>提升硬件的利用率</strong>，再具体点来说，就是提升** I/O 的利用率**和 <strong>CPU 的利用率</strong>。<br>
对于 <em>CPU 密集型的计算场景</em>，理论上“线程的数量 =CPU 核数”就是最合适的。不过在工程上，线程的数量一般会设置为「CPU 核数 +1」。</p>
<blockquote>
<p>当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。</p>
</blockquote>
<p>对于 I/O 密集型计算场景，最佳的线程数是与程序中 CPU 计算和 I/O 操作的耗时比相关的。<br>
单核：<code>最佳线程数 =1 +（I/O 耗时 / CPU 耗时）</code><br>
多核：<code>最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]</code><br>
经验值：<code>最佳线程数 = 2 * CPU 的核数 + 1</code></p>
<blockquote>
<p>测试IO/CPU 这个耗时比例可以使用APM工具(Application Performance Monitor)。可以参考的APM工具：Google Dapper、zipkin、pinpoint、Skywalking。<br>
实际工作中，不同的 I/O 模型对最佳线程数的影响非常大，例如大名鼎鼎的 Nginx 用的是非阻塞 I/O，采用的是多进程单线程结构，Nginx 本来是一个 I/O 密集型系统，但是最佳进程数设置的却是 CPU 的核数，完全参考的是 CPU 密集型的算法。所以，理论我们还是要活学活用。</p>
</blockquote>
<h2 id="用面向对象的思想写并发编程">用面向对象的思想写并发编程</h2>
<p>在 Java 语言里，面向对象思想能够让并发编程变得更简单。<br>
如何才能用面向对象思想写好并发程序呢？结合我自己的工作经验来看，我觉得你可以从封装共享变量、识别共享变量间的约束条件和制定并发访问策略这三个方面下手。</p>
<h3 id="封装共享变量">封装共享变量</h3>
<p>将共享变量作为对象属性封装在内部，对所有公共方法制定并发访问策略。</p>
<pre><code class="language-java">public class Counter {
  private long value;
  synchronized long get(){
    return value;
  }
  synchronized long addOne(){
    return ++value;
  }
}
</code></pre>
<p>对于这些不会发生变化的共享变量，建议用 final 关键字来修饰。这样既能避免并发问题，也能很明了地表明你的设计意图，让后面接手你程序的兄弟知道，你已经考虑过这些共享变量的并发安全问题了。</p>
<h3 id="识别共享变量间的约束条件">识别共享变量间的约束条件</h3>
<p>识别共享变量间的约束条件非常重要。因为这些约束条件，决定了并发访问策略。例如，库存管理里面有个合理库存的概念，库存量不能太高，也不能太低，它有一个上限和一个下限。在类 SafeWM 中，声明了两个成员变量 upper 和 lower，分别代表库存上限和库存下限，这两个变量用了 AtomicLong 这个原子类，原子类是线程安全的，所以这两个成员变量的 set 方法就不需要同步了。</p>
<pre><code class="language-java">public class SafeWM {
  // 库存上限
  private final AtomicLong upper = new AtomicLong(0);
  // 库存下限
  private final AtomicLong lower = new AtomicLong(0);
  // 设置库存上限
  void setUpper(long v){
    // 检查参数合法性
    if (v &lt; lower.get()) {
      throw new IllegalArgumentException();
    }
    upper.set(v);
  }
  // 设置库存下限
  void setLower(long v){
    // 检查参数合法性
    if (v &gt; upper.get()) {
      throw new IllegalArgumentException();
    }
    lower.set(v);
  }
  // 省略其他业务代码
}
</code></pre>
<p>在设计阶段，我们一定要识别出所有共享变量之间的约束条件，如果约束条件识别不足，很可能导致制定的并发访问策略南辕北辙。<br>
共享变量之间的约束条件，反映在代码里，基本上都会有 if 语句，所以，一定要<strong>特别注意竞态条件</strong>。</p>
<h3 id="制定并发访问策略">制定并发访问策略</h3>
<p>从方案上来看，无外乎就是以下“三件事”。</p>
<ul>
<li>避免共享：避免共享的技术主要是利于线程本地存储以及为每个任务分配独立的线程。</li>
<li>不变模式：这个在 Java 领域应用的很少，但在其他领域却有着广泛的应用，例如 Actor 模式、CSP 模式以及函数式编程的基础都是不变模式。</li>
<li>管程及其他同步工具：Java 领域万能的解决方案是管程，但是对于很多特定场景，使用 Java 并发包提供的读写锁、并发容器等同步工具会更好。</li>
</ul>
<h3 id="宏观原则">宏观原则</h3>
<p>除了这些方案之外，还有一些宏观的原则需要你了解。这些宏观原则，有助于你写出“健壮”的并发程序。这些原则主要有以下三条。</p>
<ul>
<li>优先使用成熟的工具类：Java SDK 并发包里提供了丰富的工具类，基本上能满足你日常的需要，建议你熟悉它们，用好它们，而不是自己再“发明轮子”，毕竟并发工具类不是随随便便就能发明成功的。</li>
<li>迫不得已时才使用低级的同步原语：低级的同步原语主要指的是 synchronized、Lock、Semaphore 等，这些虽然感觉简单，但实际上并没那么简单，一定要小心使用。</li>
<li>避免过早优化：安全第一，并发程序首先要保证安全，出现性能瓶颈后再优化。在设计期和开发期，很多人经常会情不自禁地预估性能的瓶颈，并对此实施优化，但残酷的现实却是：性能瓶颈不是你想预估就能预估的。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java并发编程笔记[1]——并发理论基础（上）]]></title>
        <id>https://yeyouluo.github.io/post/java-bing-fa-bian-cheng-bi-ji-1-bing-fa-li-lun-ji-chu/</id>
        <link href="https://yeyouluo.github.io/post/java-bing-fa-bian-cheng-bi-ji-1-bing-fa-li-lun-ji-chu/">
        </link>
        <updated>2020-06-18T00:59:45.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="并发编程bug源头">并发编程Bug源头</h2>
<h3 id="解决cpu-内存-io设备三者速度差异问题">解决CPU、内存、I/O设备三者速度差异问题</h3>
<p>为了合理利用CPU的高性能，平衡三者之间的差异，计算机体系结构、操作系统、编译程序都做出了贡献（简记：硬件、操作系统、应用软件三个层面的优化）：</p>
<ul>
<li>CPU增加缓存，均衡与内存的差异；</li>
<li>操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理的应用。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="并发编程bug源头">并发编程Bug源头</h2>
<h3 id="解决cpu-内存-io设备三者速度差异问题">解决CPU、内存、I/O设备三者速度差异问题</h3>
<p>为了合理利用CPU的高性能，平衡三者之间的差异，计算机体系结构、操作系统、编译程序都做出了贡献（简记：硬件、操作系统、应用软件三个层面的优化）：</p>
<ul>
<li>CPU增加缓存，均衡与内存的差异；</li>
<li>操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理的应用。</li>
</ul>
<!-- more -->
<h3 id="副作用">副作用</h3>
<p>由此带来的副作用：</p>
<ul>
<li>
<p>缓存导致可见性问题<br>
一个线程对共享变量的修改，另一个线程能够立刻看到，称为「可见性」<br>
CPU多核时代</p>
</li>
<li>
<p>线程切换带来原子性问题<br>
早期操作系统基于<strong>进程</strong>切换CPU，不同进程间不共享内存空间 ==&gt; 任务切换需要切换内存映射地址<br>
现代操作系统基于<strong>线程</strong>切换CPU，一个进程创建的所有线程共享内存空间 ==&gt; 切换线程很『轻量』<br>
一个或者多个操作在CPU执行的过程汇总不被中断的特性，称为「原子性」</p>
</li>
<li>
<p>编译优化带来有序性问题<br>
「有序性」指程序按照代码的先后顺序执行<br>
编译器为了优化性能，有时会改变程序中语句的先后顺序</p>
<p>以上副作用可以简记为：缓存导致的可见性问题、线程切换带来的原子性问题、便以优化带来的有序性问题。</p>
</li>
</ul>
<h2 id="解决可见性有序性问题java内存模型">解决可见性&amp;有序性问题：Java内存模型</h2>
<h3 id="解决可见性有序性的基本思路">解决可见性&amp;有序性的基本思路</h3>
<p>导致可见性&amp;有序性问题的根本原因是缓存和编译优化，那么直接的办法就是：禁用缓存、禁用编译优化。但如此就没法享受高性能了。这是典型的因噎废食。<br>
合理的方案是：<strong>按需禁用缓存及编译优化</strong>。『按需』其实就是程序员来控制何时禁用。</p>
<h3 id="java内存模型">Java内存模型</h3>
<p>Java内存模型 规范了JVM如何提供按需禁用缓存和编译优化的方法。<br>
具体地说，这些方法包括：</p>
<ul>
<li>volatile</li>
<li>synchronized</li>
<li>final</li>
<li>Happens-Before规则</li>
</ul>
<blockquote>
<p>注意：这些方法并不是互斥的关系。</p>
</blockquote>
<h3 id="happens-before-7个规则">Happens-Before 7个规则</h3>
<ul>
<li><strong>程序次序规则</strong>：在一个线程内一段代码的执行结果是有序的。指令还会重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。</li>
<li><strong>管程锁定规则</strong>：无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。(管程是一种通用的同步原语，synchronized就是管程的实现）</li>
<li><strong>volatile变量规则</strong>：如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</li>
<li><strong>线程启动规则</strong>：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li>
<li><strong>线程终止规则</strong>：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</li>
<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</li>
<li><strong>传递规则</strong>：happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。</li>
<li><strong>对象终结规则</strong>：一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</li>
</ul>
<blockquote>
<p>上面的理解来自网络文章<a href="https://baijiahao.baidu.com/s?id=1628346233476376109&amp;wfr=spider&amp;for=pc">面试官：谈谈happens-before?</a>，有删改。</p>
</blockquote>
<h2 id="互斥锁解决原子性问题-保护临界资源">互斥锁：解决原子性问题 &amp; 保护临界资源</h2>
<h3 id="互斥锁模型">互斥锁模型</h3>
<p><img src="https://yeyouluo.github.io/post-images/1592803711702.png" alt="锁模型" loading="lazy"><br>
这个模型更像现实世界里面球赛门票的管理，一个座位只允许一个人使用，这个座位就是“受保护资源”，球场的入口就是 Java 类里的方法，而门票就是用来保护资源的“锁”，Java 里的检票工作是由 synchronized 解决的。</p>
<h3 id="synchronized关键字">synchronized关键字</h3>
<blockquote>
<p>当修饰静态方法的时候，锁定的是当前类的 Class 对象；当修饰非静态方法的时候，锁定的是当前实例对象 this。<br>
<img src="https://yeyouluo.github.io/post-images/1592804280384.png" alt="两把锁保护一个资源示意图" loading="lazy"><br>
如果一个synchronized修饰的静态方法和一个synchronized修饰的普通方法，都对一个变量（资源）进行了保护（多把锁保护一个资源），这两个临界区并没有互斥的关系，即使加了锁（其实是两把），可能就出现并发问题了。</p>
</blockquote>
<blockquote>
<p>受保护资源和锁之间合理的关联关系应该是 N:1 的关系，也就是说可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源。</p>
</blockquote>
<h3 id="保护多个资源">保护多个资源</h3>
<h4 id="保护没有关联关系的多个资源">保护没有关联关系的多个资源</h4>
<p>用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁还有个名字，叫<strong>细粒度锁</strong>。<br>
使用细粒度锁可以提高并行度，是<strong>性能优化</strong>的一个重要手段。<br>
使用细粒度锁是有代价的，这个代价就是可能会导致<strong>死锁</strong>。</p>
<h4 id="保护有关联关系的多个资源">保护有关联关系的多个资源</h4>
<p>用同一把锁来保护多个资源，也就是现实世界的“包场”，那在编程领域应该怎么“包场”呢？很简单，只要我们的<strong>锁能覆盖所有受保护资源</strong>就可以了。</p>
<h3 id="原子性本质">『原子性』本质</h3>
<p>『原子性』的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是<strong>多个资源间有一致性的要求，操作的中间状态对外不可见</strong>。例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A 减少了 100，账户 B 还没来得及发生变化）。所以<strong>解决原子性问题，是要保证中间状态对外不可见</strong>。</p>
<h2 id="死锁">死锁</h2>
<p>有个叫 Coffman 的牛人早就总结过了，只有以下这四个条件都发生时才会出现死锁：</p>
<ol>
<li>互斥，共享资源 X 和 Y 只能被一个线程占用；</li>
<li>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li>
<li>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</li>
<li>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li>
</ol>
<p>反过来分析，也就是说只要我们<strong>破坏其中一个，就可以成功避免死锁的发生</strong>。<br>
其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</p>
<ul>
<li>对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li>
<li>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li>
<li>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li>
</ul>
<h3 id="破坏占用且等待条件">破坏占用且等待条件</h3>
<p>Allocator。它有两个重要功能，分别是：同时申请资源 apply() 和同时释放资源 free()。账户 Account 类里面持有一个 Allocator 的单例（必须是单例，只能由一个人来分配资源）。当账户 Account 在执行转账操作的时候，首先向 Allocator 同时申请转出账户和转入账户这两个资源，成功后再锁定这两个资源；当转账操作执行完，释放锁之后，我们需通知 Allocator 同时释放转出账户和转入账户这两个资源。</p>
<pre><code class="language-java">class Allocator {
  private List&lt;Object&gt; als =  new ArrayList&lt;&gt;();
  // 一次性申请所有资源
  synchronized boolean apply(
    Object from, Object to){
    if(als.contains(from) ||
         als.contains(to)){
      return false;  
    } else {
      als.add(from);
      als.add(to);  
    }
    return true;
  }
  // 归还资源
  synchronized void free(
    Object from, Object to){
    als.remove(from);
    als.remove(to);
  }
}

class Account {
  // actr应该为单例
  private Allocator actr;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 一次性申请转出账户和转入账户，直到成功
    while(!actr.apply(this, target))
      ；
    try{
      // 锁定转出账户
      synchronized(this){              
        // 锁定转入账户
        synchronized(target){           
          if (this.balance &gt; amt){
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } finally {
      actr.free(this, target)
    }
  } 
}
</code></pre>
<h3 id="破坏不可抢占条件">破坏不可抢占条件</h3>
<p>核心是要能够主动释放它占有的资源，这一点 synchronized 是做不到的。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。<br>
<code>java.util.concurrent</code> 这个包下面提供的 Lock 是可以轻松解决这个问题的。</p>
<h3 id="破坏循环等待条件">破坏循环等待条件</h3>
<p>破坏这个条件，需要对资源进行排序，然后按序申请资源。这个实现非常简单，我们假设每个账户都有不同的属性 id，这个 id 可以作为排序字段，申请的时候，我们可以按照从小到大的顺序来申请。比如下面代码中，①~⑥处的代码对转出账户（this）和转入账户（target）排序，然后按照序号从小到大的顺序锁定账户。这样就不存在“循环”等待了。</p>
<pre><code class="language-java">class Account {
  private int id;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    Account left = this        ①
    Account right = target;    ②
    if (this.id &gt; target.id) { ③
      left = target;           ④
      right = this;            ⑤
    }                          ⑥
    // 锁定序号小的账户
    synchronized(left){
      // 锁定序号大的账户
      synchronized(right){ 
        if (this.balance &gt; amt){
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
</code></pre>
<h3 id="使用等待-通知机制优化循环等待">使用「等待-通知」机制优化循环等待</h3>
<h4 id="等待-通知机制">「等待-通知」机制</h4>
<p>一个完整的「等待 - 通知」机制：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁。</p>
<h4 id="java中等待-通知实现">Java中「等待-通知」实现</h4>
<p>在 Java 语言里，等待 - 通知机制可以有多种实现方式，比如 Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法就能轻松实现。</p>
<pre><code class="language-java">
class Allocator {
  private List&lt;Object&gt; als;
  // 一次性申请所有资源
  synchronized void apply(
    Object from, Object to){
    // 经典写法
    while(als.contains(from) ||
         als.contains(to)){
      try{
        wait();
      }catch(Exception e){
      }   
    } 
    als.add(from);
    als.add(to);  
  }
  // 归还资源
  synchronized void free(
    Object from, Object to){
    als.remove(from);
    als.remove(to);
    notifyAll();
  }
}
</code></pre>
<h2 id="致谢">致谢</h2>
<p>系列文章都是来自极客时间专栏《Java并发编程实战》，感谢作者王宝令老师。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决postman无法发送数组参数的问题]]></title>
        <id>https://yeyouluo.github.io/post/jie-jue-postman-wu-fa-fa-song-shu-zu-can-shu-de-wen-ti/</id>
        <link href="https://yeyouluo.github.io/post/jie-jue-postman-wu-fa-fa-song-shu-zu-can-shu-de-wen-ti/">
        </link>
        <updated>2020-06-11T05:48:26.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="问题">问题</h2>
<p>postman在web开发中很有用。但我遇到了postman无法发送数组参数的问题。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<p>postman在web开发中很有用。但我遇到了postman无法发送数组参数的问题。</p>
<!-- more -->
<h2 id="环境">环境</h2>
<ul>
<li>win10企业版</li>
<li>Postman-win64-6.1.4</li>
<li>web框架：<a href="https://github.com/visallo/webster/">webster</a></li>
</ul>
<h2 id="解决">解决</h2>
<h3 id="未成功">未成功</h3>
<p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_21205435/article/details/81909184">postman发送数组</a></li>
<li><a href="https://www.deepworker.online/article?id=18">如何使用postman传数组数据</a><br>
经过尝试，虽然没成功，但提供了一些解决问题的视角。在此衷心表示感谢。</li>
</ul>
<h3 id="成功">成功</h3>
<p><img src="https://yeyouluo.github.io/post-images/1591856505757.png" alt="" loading="lazy"><br>
解决思路比较简单，就是将这个key再写一次。<br>
这个解决思路是从后端错误追踪Webster源码得到的。具体内容后续文章展开。</p>
<h2 id="其他postman的资料">其他postman的资料</h2>
<ul>
<li><a href="https://www.jellythink.com/tool-tutorials/postman">果冻想博客--工具教程--postman</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jenkins屏蔽windows、Linux slave差异]]></title>
        <id>https://yeyouluo.github.io/post/jenkins-ping-bi-windowslinux-slave-chai-yi/</id>
        <link href="https://yeyouluo.github.io/post/jenkins-ping-bi-windowslinux-slave-chai-yi/">
        </link>
        <updated>2020-06-06T14:07:31.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="背景及目标">背景及目标</h2>
<p>由于未能解决前端在linux上的打包问题，临时采用在slave（windows）上编译前端vue代码，再和master（linux）整合。如果使用jenkins pipeline作业，就可以在一个作业里整合全部的操作。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="背景及目标">背景及目标</h2>
<p>由于未能解决前端在linux上的打包问题，临时采用在slave（windows）上编译前端vue代码，再和master（linux）整合。如果使用jenkins pipeline作业，就可以在一个作业里整合全部的操作。</p>
<!-- more -->
<h2 id="环境说明">环境说明</h2>
<ul>
<li>Centos7</li>
<li>Jenkins 2.150.1</li>
<li>windows 10</li>
</ul>
<h2 id="前置工作">前置工作</h2>
<ul>
<li>配置windows slave，使用JNLP连接</li>
</ul>
<h2 id="pipeline脚本">pipeline脚本</h2>
<pre><code class="language-groovy">node(&quot;master&quot;){
    stage(&quot;环境清理&quot;){
	   sh '''
	        if [ ! -d &quot;${WORKSPACE}/../${JOB_NAME}_support&quot; ];then 
    			mkdir -p ${WORKSPACE}/../${JOB_NAME}_support
    		fi;
            if [ ! -f &quot;${WORKSPACE}/../${JOB_NAME}_support/dist.tgz&quot; ];then
				echo &quot;dist.tgz不存在！&quot;
			else
				rm -rf ${WORKSPACE}/../${JOB_NAME}_support/dist*
				echo &quot;删除dist.tgz成功！&quot;
			fi
        '''		
	}
}
node(&quot;windows-slave&quot;){
   stage('拉取代码') { // for display purposes
      // Get some code from a GitHub repository
      checkout([$class: 'GitSCM', branches: [[name: &quot;*/master&quot;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'c087b96d-3c22-4701-a51b-68a38b74d1a1', url: 'http://xxx-Front.git']]])
   }
   stage('npm打包'){
       bat '''![](https://yeyouluo.github.io/post-images/1591453418202.png)
            cd %WORKSPACE%
            rd /s/q dist
            npm run build
        '''
   }
    stage('传输部署包'){
       bat '''
            cd %WORKSPACE%
            tar zcvf dist.tgz dist
			scp dist.tgz hadoop@slave105:/home/hadoop/base/jenkins/data/workspace/%JOB_NAME%_support
        '''
   }
}

node(&quot;master&quot;){
   stage('拉取代码') { // for display purposes
      // Get some code from a GitHub repository
      checkout([$class: 'GitSCM', branches: [[name: &quot;*/6s&quot;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'c087b96d-3c22-4701-a51b-68a38b74d1a1', url: 'xxx-backend.git']]])
   }
   stage('整合前端文件') { // for display purposes
      sh '''
	    cd ${WORKSPACE}/../${JOB_NAME}_support
		tar zxvf dist.tgz
        if [ ! -d &quot;${WORKSPACE}/web/war/src/main/webapp&quot; ];then 
			mkdir -p ${WORKSPACE}/web/war/src/main/webapp
		fi;
		if [ -d &quot;${WORKSPACE}/web/war/src/main/webapp/static&quot; ];then 
			rm -rf ${WORKSPACE}/web/war/src/main/webapp/static
		fi;
		if [ -f &quot;${WORKSPACE}/web/war/src/main/webapp/index.html&quot; ];then 
			rm -f ${WORKSPACE}/web/war/src/main/webapp/index.html
		fi;		
        mv ${WORKSPACE}/../${JOB_NAME}_support/dist/* ${WORKSPACE}/web/war/src/main/webapp
      '''
   }
   stage('编译打包') { // for display purposes
   // Run the maven build
      if (isUnix()) {
         sh '''
            mvn clean package -DskipTests=true
         '''
       } else {
          bat(&quot;mvn clean package -DskipTests=true&quot;)
      }
   }
}
node(&quot;linux-slave-tomcat&quot;){
    stage('停止tomcat') { // for display purposes
  }
}
node(&quot;master&quot;){
  stage('替换war') { // for display purposes
  }
}
node(&quot;master&quot;){
  stage('启动tomcat') { // for display purposes

  }
}

</code></pre>
<h2 id="思路">思路</h2>
<ul>
<li>在windows slave上执行npm打包，将打包文件压缩成tarball（使用Cygwin环境命令），并上传到master jenkins data目录下（job平级目录创建了一个<code>_support</code>目录，tarball放到这个目录下）</li>
<li>在master主机上打包后端项目，并和前端部署脚本做整合</li>
<li>重启tomcat脚本去掉了，因为含有部分敏感信息。
<blockquote>
<p>由于主机等敏感信息来自于公司内网，因此上述脚本说了阉割处理。</p>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法入门]]></title>
        <id>https://yeyouluo.github.io/post/shu-ju-jie-gou-yu-suan-fa-ru-men/</id>
        <link href="https://yeyouluo.github.io/post/shu-ju-jie-gou-yu-suan-fa-ru-men/">
        </link>
        <updated>2020-05-25T23:44:52.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="为什么要学习数据结构与算法">为什么要学习数据结构与算法</h2>
<ul>
<li>能够写出质量更高的代码</li>
<li>掌握数据结构与算法，有助于理解框架源码及框架的设计思想</li>
<li>应付大厂面试</li>
</ul>
<h2 id="数据机构与算法的关系">数据机构与算法的关系</h2>
<p>数据结构是为算法服务的，算法要作用在特定的数据结构之上。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="为什么要学习数据结构与算法">为什么要学习数据结构与算法</h2>
<ul>
<li>能够写出质量更高的代码</li>
<li>掌握数据结构与算法，有助于理解框架源码及框架的设计思想</li>
<li>应付大厂面试</li>
</ul>
<h2 id="数据机构与算法的关系">数据机构与算法的关系</h2>
<p>数据结构是为算法服务的，算法要作用在特定的数据结构之上。</p>
<!-- more -->
<h2 id="数据结构与算法学习重点">数据结构与算法学习重点</h2>
<ul>
<li>复杂度分析</li>
<li>数据结构与算法全景图（无需全部掌握）<br>
<img src="https://yeyouluo.github.io/post-images/1590451269433.jpg" alt="" loading="lazy"></li>
<li>常用点&amp;重点
<ul>
<li>10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树</li>
<li>10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</li>
</ul>
</li>
</ul>
<h2 id="数据结构与算法学习技巧">数据结构与算法学习技巧</h2>
<ul>
<li>
<p>边学边练，适度刷题<br>
建议每周花 1～2 个小时的时间，自己用代码全部实现一遍。</p>
<blockquote>
<p>王争观点：可以“适度”刷题，但一定不要浪费太多时间在刷题上。我们学习的目的还是掌握，然后应用。除非你要面试 Google、Facebook 这样的公司，它们的算法题目非常非常难，必须大量刷题，才能在短期内提升应试正确率。如果是应对国内公司的技术面试，即便是 BAT 这样的公司，你只要彻底掌握这个专栏的内容，就足以应对。</p>
</blockquote>
</li>
<li>
<p>多问、多思考、多互动</p>
</li>
<li>
<p>打怪升级学习法</p>
<ul>
<li>设立一个切实可行的目标</li>
<li>要有输出（这也是我写系列学习笔记的目的所在）</li>
</ul>
</li>
<li>
<p>知识需要沉淀，不要想试图一下子掌握所有</p>
<blockquote>
<p>在学习的过程中，一定会碰到“拦路虎”。如果哪个知识点没有怎么学懂，不要着急，这是正常的。因为，想听一遍、看一遍就把所有知识掌握，这肯定是不可能的。学习知识的过程是反复迭代、不断沉淀的过程。</p>
</blockquote>
</li>
</ul>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="复杂度分析课程地位">复杂度分析课程地位</h3>
<p>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p>
<h3 id="为何需要复杂度分析">为何需要复杂度分析</h3>
<p><strong>事后统计法</strong>有很大的局限性：</p>
<ul>
<li>测试结果非常依赖测试环境</li>
<li>测试结果受数据规模的影响很大</li>
</ul>
<p>所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法，即时间、空间复杂度分析方法。</p>
<h3 id="时间复杂度分析">时间复杂度分析</h3>
<h4 id="概念">概念</h4>
<p><strong>大 O 时间复杂度</strong>实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的<u>变化趋势</u>，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p>
<h4 id="时间复杂度实用方法">时间复杂度实用方法</h4>
<ol>
<li>只关注循环执行次数最多的一段代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>
<h4 id="常见的时间复杂度">常见的时间复杂度</h4>
<p><img src="https://yeyouluo.github.io/post-images/1590467016694.jpg" alt="" loading="lazy"><br>
对于上图罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。<br>
<img src="https://yeyouluo.github.io/post-images/1590467046059.jpg" alt="" loading="lazy"><br>
我们把时间复杂度为非多项式量级的算法问题叫作 <strong>NP（Non-Deterministic Polynomial，非确定多项式）问题</strong>。</p>
<p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，<strong>非多项式时间复杂度的算法其实是非常低效的算法</strong>。以下是几种常见的多项式时间复杂度：</p>
<ol>
<li>O(1)</li>
</ol>
<p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p>
<ol start="2">
<li>O(logn)、O(nlogn)</li>
</ol>
<blockquote>
<p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p>
</blockquote>
<p>比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>
<ol start="3">
<li>O(m+n)、O(m*n)</li>
</ol>
<p>有两个数据规模，我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。</p>
<h4 id="最好-最坏-平均-均摊时间复杂度">最好、最坏、平均、均摊时间复杂度</h4>
<p>好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。<br>
最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。<br>
平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。</p>
<blockquote>
<p>很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。</p>
</blockquote>
<p>均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</p>
<h3 id="空间复杂度分析">空间复杂度分析</h3>
<h4 id="概念-2">概念</h4>
<p>空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p>
<h4 id="常见的时间复杂度-2">常见的时间复杂度</h4>
<p>常见的空间复杂度就是 O(1)、O(n)、O(n2) 。</p>
<blockquote>
<ol>
<li>O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到 。</li>
<li>空间复杂度分析比时间复杂度分析要简单很多。</li>
</ol>
</blockquote>
<h2 id="工具">工具</h2>
<ul>
<li>算法可视化网站：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></li>
</ul>
<h2 id="书籍推荐">书籍推荐</h2>
<p>by王争<br>
<img src="https://yeyouluo.github.io/post-images/1590510118154.jpg" alt="" loading="lazy"></p>
<h2 id="重难点一览表">重难点一览表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>难易程序</th>
<th>重点</th>
<th>掌握程度</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复杂度分析</td>
<td>Medium</td>
<td>10</td>
<td>在不看我的分析的情况下，能自行分析专栏中大部分数据结构和算法的时间、空间复杂度</td>
</tr>
<tr>
<td>2</td>
<td>数组、栈、队列</td>
<td>Easy</td>
<td>8</td>
<td>能自己实现动态数组、栈、队列</td>
</tr>
<tr>
<td>3</td>
<td>链表</td>
<td>Medium</td>
<td>9</td>
<td>能轻松写出经典链表题目代码</td>
</tr>
<tr>
<td>4</td>
<td>递归</td>
<td>Hard</td>
<td>10</td>
<td>轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码</td>
</tr>
<tr>
<td>5</td>
<td>排序、二分查找</td>
<td>Easy</td>
<td>7</td>
<td>能自己把各种排序算法、二分查找及其变体代码写一遍就可以</td>
</tr>
<tr>
<td>6</td>
<td>跳表</td>
<td>Medium</td>
<td>6</td>
<td>初学者可以先跳过。如果感兴趣，看懂专栏内容即可，不需要掌握代码实现</td>
</tr>
<tr>
<td>7</td>
<td>散列表</td>
<td>Medium</td>
<td>8</td>
<td>对于初学者来说，自己能代码实现一个拉链法解决冲突的散列表即可</td>
</tr>
<tr>
<td>8</td>
<td>哈希算法</td>
<td>Easy</td>
<td>3</td>
<td>可以暂时不看</td>
</tr>
<tr>
<td>9</td>
<td>二叉树</td>
<td>Medium</td>
<td>9</td>
<td>能代码实现二叉树的三种遍历算法、按层遍历、求高度等经典二叉树题目</td>
</tr>
<tr>
<td>10</td>
<td>红黑树</td>
<td>Hard</td>
<td>3</td>
<td>初学者不用把时间浪费在上面</td>
</tr>
<tr>
<td>11</td>
<td>B+ 树</td>
<td>Medium</td>
<td>5</td>
<td>可看可不看</td>
</tr>
<tr>
<td>12</td>
<td>堆与堆排序</td>
<td>Medium</td>
<td>8</td>
<td>能代码实现堆、堆排序，并且掌握堆的三种应用（优先级队列、Top k、中位数）</td>
</tr>
<tr>
<td>13</td>
<td>图的表示</td>
<td>Easy</td>
<td>8</td>
<td>理解图的三种表示方法（邻接矩阵、邻接表、逆邻接表），能自己代码实现</td>
</tr>
<tr>
<td>14</td>
<td>深度广度优先搜索</td>
<td>Hard</td>
<td>8</td>
<td>能代码实现广度优先、深度优先搜索算法。建议放在最后挑战。</td>
</tr>
<tr>
<td>15</td>
<td>拓扑排序、最短路径、A* 算法</td>
<td>Hard</td>
<td>5</td>
<td>有时间再看，暂时可以不看</td>
</tr>
<tr>
<td>16</td>
<td>字符串匹配（BF、RK）</td>
<td>Easy</td>
<td>7</td>
<td>能实践 BF 算法，能看懂 RK 算法</td>
</tr>
<tr>
<td>17</td>
<td>字符串匹配（BM、KMP、AC 自动机）</td>
<td>Hard</td>
<td>3</td>
<td>初学者不用把时间浪费在上面</td>
</tr>
<tr>
<td>18</td>
<td>字符串匹配（Trie）</td>
<td>Medium</td>
<td>7</td>
<td>能看懂，知道特点、应用场景即可，不要求代码实现</td>
</tr>
<tr>
<td>19</td>
<td>位图</td>
<td>Easy</td>
<td>6</td>
<td>看懂即可，能自己实现一个位图结构最好</td>
</tr>
<tr>
<td>20</td>
<td>四种算法思想</td>
<td>Hard</td>
<td>10</td>
<td>以放到最后，但是一定要掌握！做到能实现 Leetcode 上 Medium 难度的题目</td>
</tr>
</tbody>
</table>
<h2 id="致谢">致谢</h2>
<p>本系列笔记均来自于极客时间专栏《数据结构与算法之美》，作者王争。感谢极客时间及王争，能提供这么高质量的课程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot集成MybatisPlus]]></title>
        <id>https://yeyouluo.github.io/post/springboot-ji-cheng-mybatisplus/</id>
        <link href="https://yeyouluo.github.io/post/springboot-ji-cheng-mybatisplus/">
        </link>
        <updated>2020-05-23T09:22:34.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="mybatisplus">MyBatisPlus</h2>
<p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。<br>
<a href="https://mybatis.plus/">MyBatisPlus官网</a></p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="mybatisplus">MyBatisPlus</h2>
<p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。<br>
<a href="https://mybatis.plus/">MyBatisPlus官网</a></p>
<!-- more -->
<h2 id="操作">操作</h2>
<p>参考<a href="https://mybatis.plus/guide/quick-start.html">MP快速开始</a>。文档写的很清晰，按图索骥即可，此处不再赘述。</p>
<h2 id="注意点">注意点</h2>
<ul>
<li>要么在入口类添加<code>@MapperScan(&quot;com.yeyouluo.mpspringboot.mapper&quot;)</code>注解，要么在<code>Mapper</code>类上添加<code>@Mapper</code>注解。否则启动报错。</li>
<li>如果要使用分页查询，还需要额外的配置，否则启动报错。</li>
<li>更多MyBatisPlus示例参考<a href="https://github.com/baomidou/mybatis-plus-samples">Github<br>
mybatis-plus-samples</a>。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot集成MyBatis]]></title>
        <id>https://yeyouluo.github.io/post/springboot-ji-cheng-mybatis/</id>
        <link href="https://yeyouluo.github.io/post/springboot-ji-cheng-mybatis/">
        </link>
        <updated>2020-05-23T08:20:33.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="mybatis">MyBatis</h2>
<p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。<br>
<a href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis官方文档</a></p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="mybatis">MyBatis</h2>
<p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。<br>
<a href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis官方文档</a></p>
<!-- more -->
<h2 id="操作">操作</h2>
<h3 id="数据准备">数据准备</h3>
<ul>
<li>建立名为<code>springboot</code>的<code>database</code></li>
<li>建立名为<code>user</code>的表<br>
<img src="https://yeyouluo.github.io/post-images/1590222199853.png" alt="" loading="lazy"></li>
<li>插入两条测试数据</li>
</ul>
<h3 id="pomxml引入mybatis和mysql相关依赖">pom.xml引入MyBatis和MySQL相关依赖</h3>
<pre><code class="language-xml"> &lt;dependency&gt;
     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
     &lt;version&gt;1.3.0&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;mysql&lt;/groupId&gt;
     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
     &lt;version&gt;5.1.49&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre>
<h3 id="加入配置">加入配置</h3>
<p>在<code>application.properties</code>中加入如下配置：</p>
<pre><code class="language-properties"> spring.datasource.driver-class-name=com.mysql.jdbc.Driver
 spring.datasource.url=jdbc:mysql://192.168.147.200:3307/springboot?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull
 spring.datasource.username=root
 spring.datasource.password=qwert
 #mybatis.config-location=classpath:mapper/*.xml
</code></pre>
<blockquote>
<p>因为我们不会采用xml编写mapper的方式，仅此将<code>mybatis.config-location=classpath:mapper/*.xml</code>注释掉。否则就需要在<code>resources</code>目录下建立<code>mapper</code>目录，所有的SQL放在<code>*.xml</code>中。</p>
</blockquote>
<h3 id="编写mapper">编写mapper</h3>
<pre><code class="language-java"> package com.yeyouluo.hellospringboot.mapper;

 import com.yeyouluo.hellospringboot.domain.User;
 import org.apache.ibatis.annotations.Insert;
 import org.apache.ibatis.annotations.Mapper;
 import org.apache.ibatis.annotations.Param;
 import org.apache.ibatis.annotations.Select;

 /**
 * @Auther: yeyouluo
 * @Date: 2020/5/23
 */
 @Mapper
 public interface UserMapper {
     @Select(&quot;select * from user where id = #{id}&quot;)
     User getUserById(@Param(&quot;id&quot;) Integer id);

     @Insert(&quot;insert into user (`name`, `sex`) values (#{name}, #{sex})&quot;)
     void insertUser(@Param(&quot;name&quot;) String name, @Param(&quot;sex&quot;) String sex);
 }
</code></pre>
<h3 id="编写controller">编写Controller</h3>
<p>在<code>HelloController</code>类种添加两个方法：</p>
<pre><code class="language-java"> @Autowired
 private UserMapper userMapper;

 @GetMapping(&quot;/user/{id}&quot;)
 public User getUser(@PathVariable Integer id) {
     return userMapper.getUserById(id);
 }

 @PostMapping(&quot;/user&quot;)
 public String insertUser(String name, String sex) {
     userMapper.insertUser(name, sex);
     return &quot;sucess&quot;;
 }
</code></pre>
<h3 id="测试">测试</h3>
<h4 id="测试查询接口">测试查询接口</h4>
<figure data-type="image" tabindex="1"><img src="https://yeyouluo.github.io/post-images/1590222862273.png" alt="" loading="lazy"></figure>
<h4 id="测试插入接口">测试插入接口</h4>
<ul>
<li>使用postman发送<code>POST</code>请求：<br>
<img src="https://yeyouluo.github.io/post-images/1590222942691.png" alt="" loading="lazy"></li>
<li>查看数据库插入结果：<br>
<img src="https://yeyouluo.github.io/post-images/1590223039968.png" alt="" loading="lazy"></li>
<li>使用查询接口查询结果：<br>
<img src="https://yeyouluo.github.io/post-images/1590223076865.png" alt="" loading="lazy"></li>
</ul>
<h2 id="遇到的问题">遇到的问题</h2>
<h3 id="出现ssl相关警告">出现SSL相关警告</h3>
<ul>
<li>
<p>现象<br>
<code>application.properties</code>中配置<code>spring.datasource.url=jdbc:mysql://192.168.147.200:3307/springboot?useUnicode=true&amp;zeroDateTimeBehavior=convertToNull</code><br>
能够正常查询，但控制台出现错误：</p>
<pre><code>Sat May 23 15:23:31 CST 2020 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://yeyouluo.github.io/post-images/1590223160959.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>解决<br>
将配置项<code>spring.datasource.url</code>改为<code>=jdbc:mysql://192.168.147.200:3307/springboot?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</code>。</p>
<h3 id="出现字符集utf8mb4相关错误">出现字符集<code>utf8mb4</code>相关错误</h3>
</li>
<li>
<p>现象<br>
<code>application.properties</code>中配置<code>spring.datasource.url=jdbc:mysql://192.168.147.200:3307/springboot?useUnicode=true&amp;characterEncoding=utf8mb4&amp;useSSL=false</code><br>
可以启动，但是访问接口报错：</p>
</li>
</ul>
<pre><code>2020-05-23 15:36:53.489 ERROR 30188 --- [nio-8080-exec-1] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.

java.sql.SQLException: Unsupported character encoding 'utf8mb4'.
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:965) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:898) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:887) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:861) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.mysql.jdbc.ConnectionPropertiesImpl.postInitialization(ConnectionPropertiesImpl.java:2575) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.mysql.jdbc.ConnectionPropertiesImpl.initializeProperties(ConnectionPropertiesImpl.java:2545) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.mysql.jdbc.ConnectionImpl.initializeDriverProperties(ConnectionImpl.java:3109) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.mysql.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:758) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.mysql.jdbc.JDBC4Connection.&lt;init&gt;(JDBC4Connection.java:47) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.8.0_172]
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:1.8.0_172]
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.8.0_172]
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423) ~[na:1.8.0_172]
	at com.mysql.jdbc.Util.handleNewInstance(Util.java:403) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:385) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:323) ~[mysql-connector-java-5.1.49.jar:5.1.49]
	at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-3.4.5.jar:na]
	at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:358) ~[HikariCP-3.4.5.jar:na]
	at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-3.4.5.jar:na]
	at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:477) [HikariCP-3.4.5.jar:na]
	at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:560) [HikariCP-3.4.5.jar:na]
	at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) [HikariCP-3.4.5.jar:na]
	at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) [HikariCP-3.4.5.jar:na]
	at org.springframework.jdbc.datasource.DataSourceUtils.fetchConnection(DataSourceUtils.java:158) [spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:116) [spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:79) [spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.mybatis.spring.transaction.SpringManagedTransaction.openConnection(SpringManagedTransaction.java:82) [mybatis-spring-1.3.1.jar:1.3.1]
	at org.mybatis.spring.transaction.SpringManagedTransaction.getConnection(SpringManagedTransaction.java:68) [mybatis-spring-1.3.1.jar:1.3.1]
	at org.apache.ibatis.executor.BaseExecutor.getConnection(BaseExecutor.java:336) [mybatis-3.4.4.jar:3.4.4]
	at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:84) [mybatis-3.4.4.jar:3.4.4]
	at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62) [mybatis-3.4.4.jar:3.4.4]
	at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324) [mybatis-3.4.4.jar:3.4.4]
	at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) [mybatis-3.4.4.jar:3.4.4]
	at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) [mybatis-3.4.4.jar:3.4.4]
	at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) [mybatis-3.4.4.jar:3.4.4]
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) [mybatis-3.4.4.jar:3.4.4]
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) [mybatis-3.4.4.jar:3.4.4]
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:77) [mybatis-3.4.4.jar:3.4.4]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_172]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_172]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_172]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_172]
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) [mybatis-spring-1.3.1.jar:1.3.1]
	at com.sun.proxy.$Proxy56.selectOne(Unknown Source) [na:na]
	at org.mybatis.spring.SqlSessionTemplate.selectOne(SqlSessionTemplate.java:166) [mybatis-spring-1.3.1.jar:1.3.1]
	at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:82) [mybatis-3.4.4.jar:3.4.4]
	at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:59) [mybatis-3.4.4.jar:3.4.4]
	at com.sun.proxy.$Proxy59.getUserById(Unknown Source) [na:na]
	at com.yeyouluo.hellospringboot.controller.HelloController.getUser(HelloController.java:49) [classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_172]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_172]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_172]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_172]
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) [spring-web-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) [spring-web-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) [spring-webmvc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) [spring-webmvc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) [spring-webmvc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) [spring-webmvc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) [spring-webmvc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_172]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_172]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.35.jar:9.0.35]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_172]
</code></pre>
<ul>
<li>解决<br>
参考了<a href="https://blog.csdn.net/testcs_dn/article/details/75533784">https://blog.csdn.net/testcs_dn/article/details/75533784</a>，将<code>characterEncoding=utf8mb4</code>去掉。
<blockquote>
<p>注意，上面这种方式也会有副作用，即插入汉字会乱码。因此最终将字符集换成了<code>UTF-8</code>，但这仍然不是最好的解决办法。</p>
</blockquote>
</li>
</ul>
<h2 id="其他收获">其他收获</h2>
<p><img src="https://yeyouluo.github.io/post-images/1590222291857.png" alt="" loading="lazy"><br>
通过控制台打印出的日志，可以知道，SpringBoot默认的连接池是<a href="https://github.com/brettwooldridge/HikariCP">HikariPool</a>。</p>
<h2 id="springboot事务">SpringBoot事务</h2>
<p>简单来说，在需要执行事务的方法上添加一个注解<code>@Transactional</code>。可参考<a href="https://www.jianshu.com/p/9b5eb43236cc">https://www.jianshu.com/p/9b5eb43236cc</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot集成Thymeleaf]]></title>
        <id>https://yeyouluo.github.io/post/springboot-ji-cheng-thymeleaf/</id>
        <link href="https://yeyouluo.github.io/post/springboot-ji-cheng-thymeleaf/">
        </link>
        <updated>2020-05-22T16:21:25.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="jsp的缺点">JSP的缺点</h2>
<p>JSP会被编译成为Servlet，重量级。<br>
JSP的缺点就是模板的优点。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="jsp的缺点">JSP的缺点</h2>
<p>JSP会被编译成为Servlet，重量级。<br>
JSP的缺点就是模板的优点。</p>
<!-- more -->
<h2 id="除thymeleaf还有哪些模板">除Thymeleaf，还有哪些模板</h2>
<ul>
<li><a href="http://freemarker.foofun.cn/">Freemarker</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/documentation/template-engines.html">Groovy</a></li>
</ul>
<h2 id="理论">理论</h2>
<p>SpringBoot模板默认配置的目录是<code>templates</code>。</p>
<h2 id="操作">操作</h2>
<ol>
<li>
<p>引入Thymeleaf依赖（pom.xml）</p>
<pre><code class="language-xml">&lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>添加配置（可省略，则使用默认配置）</p>
<pre><code class="language-properties">spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML5
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.servlet.content-type=text/html
</code></pre>
</li>
<li>
<p>代码开发和页面效果测试</p>
<p>controller层：添加一个<code>PageController</code>类</p>
<pre><code class="language-java">package com.yeyouluo.hellospringboot.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * @Auther: yeyouluo
 * @Date: 2020/5/23
 */
@Controller
public class PageController {

    @RequestMapping(&quot;/index&quot;)
    public String index(Model model) {
        model.addAttribute(&quot;name&quot;, &quot;yeyouluo&quot;);
        return &quot;index&quot;;
    }
}
</code></pre>
<p>在<code>resources/templates</code>目录下新建一个HTML5页面<code>index.html</code>，内容如下：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;测试页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;hello,Thymeleaf&lt;/h1&gt;
    &lt;p&gt;by &lt;span th:text=&quot;${name}&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p>启动查看效果<br>
<img src="https://yeyouluo.github.io/post-images/1590166450367.png" alt="" loading="lazy"></p>
</li>
</ol>
<h2 id="其他收获">其他收获</h2>
<ul>
<li>可以使用<code>Model</code>传递给页面参数。页面使用<code>${xxx}</code>获取（<code>Thymeleaf</code>语法）。</li>
<li><code>Thymeleaf</code>基础知识（整理自<a href="https://www.jianshu.com/p/908b48b10702">https://www.jianshu.com/p/908b48b10702</a>）</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://yeyouluo.github.io/post-images/1590168591149.png" alt="" loading="lazy"></figure>
<h2 id="thymeleaf参考资料">Thymeleaf参考资料</h2>
<ul>
<li><a href="https://www.thymeleaf.org/">Thymeleaf官方文档</a></li>
<li><a href="https://www.jianshu.com/p/908b48b10702">SpringBoot Thymeleaf使用教程（实用版）</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot捕获全局异常]]></title>
        <id>https://yeyouluo.github.io/post/springboot-bu-huo-quan-ju-yi-chang/</id>
        <link href="https://yeyouluo.github.io/post/springboot-bu-huo-quan-ju-yi-chang/">
        </link>
        <updated>2020-05-21T15:16:14.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="理论">理论</h2>
<ul>
<li>从 spring 3.2 开始，新增了 <code>@ControllerAdvice</code> 注解，可以用于定义 <code>@ExceptionHandler</code>，并应用到配置了 <code>@RequestMapping</code> 的控制器中。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="理论">理论</h2>
<ul>
<li>
<p>从 spring 3.2 开始，新增了 <code>@ControllerAdvice</code> 注解，可以用于定义 <code>@ExceptionHandler</code>，并应用到配置了 <code>@RequestMapping</code> 的控制器中。</p>
<!-- more -->
<h2 id="操作">操作</h2>
<ol>
<li>定义全局异常捕捉Controller</li>
</ol>
<pre><code class="language-java">package com.yeyouluo.hellospringboot.exception;

import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(value = RuntimeException.class)
    @ResponseBody
    public String handle() {
        return &quot;捕获到全局RuntimeException&quot;;
    }
}
</code></pre>
</li>
</ul>
<ol start="2">
<li>抛出异常<pre><code class="language-java">@GetMapping(&quot;/exception&quot;)
 public String testException(){
     System.out.println(&quot;开始&quot;);

     System.out.println(2/0);

     System.out.println(&quot;结束&quot;);
     return &quot;SpringBoot OK&quot;;
 }
</code></pre>
</li>
<li>结果验证<br>
<img src="https://yeyouluo.github.io/post-images/1590075093881.png" alt="" loading="lazy"></li>
</ol>
<h2 id="局限">局限</h2>
<p>使用 <code>@ControllerAdvice</code>处理异常也有一定的 局限性。只有进入 Controller 层的错误，才会由 <code>@ControllerAdvice</code> 处理。拦截器 抛出的错误，以及 访问错误地址 的情况 <code>@ControllerAdvice</code> 处理不了，由 Spring Boot 默认的 异常处理机制 处理。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://blog.csdn.net/baidu_22254181/java/article/details/80789076">实战Spring Boot 2.0系列(二) - 全局异常处理和测试</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot访问静态文件]]></title>
        <id>https://yeyouluo.github.io/post/springboot-fang-wen-jing-tai-wen-jian/</id>
        <link href="https://yeyouluo.github.io/post/springboot-fang-wen-jing-tai-wen-jian/">
        </link>
        <updated>2020-05-21T14:22:27.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="理论知识">理论知识</h2>
<p>SpringBoot默认扫描的静态目录为<code>static</code>，因此将静态文件放到<code>static</code>目录下就可以了。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="理论知识">理论知识</h2>
<p>SpringBoot默认扫描的静态目录为<code>static</code>，因此将静态文件放到<code>static</code>目录下就可以了。</p>
<!-- more -->
<h2 id="操作">操作</h2>
<ol>
<li>将静态文件放到<code>static</code>目录<br>
<img src="https://yeyouluo.github.io/post-images/1590071471333.png" alt="" loading="lazy"></li>
<li>访问，效果符合预期<br>
<img src="https://yeyouluo.github.io/post-images/1590071481534.png" alt="" loading="lazy"><br>
<img src="https://yeyouluo.github.io/post-images/1590071490901.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
</feed>